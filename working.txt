
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');


const tilesets = TileMaps['map'].tilesets; // From your map.js


let tilesetImages = {};
let imagesLoaded = 0;
const totalImages = tilesets.length;


// Set to store gids of collidable tiles
const collideTiles = new Set();


// Set to store gids of disappearing tiles
const disappearingTiles = new Set();


// Set to track hidden tile indices dynamically on map layers
const hiddenTiles = new Set();


// Load player spritesheets for directions
const playerSprites = {
    down: new Image(),
    side: new Image(),
    up: new Image()
};
playerSprites.down.src = 'assets/Run_Down-Sheet.png';
playerSprites.side.src = 'assets/Run_right-Sheet.png';
playerSprites.up.src = 'assets/Run_Up-Sheet.png';


tilesets.forEach(tileset => {
    let img = new Image();
    img.src = tileset.image.replace(/\\/g, '/');
    img.onload = () => {
        imagesLoaded++;
        console.log(`Loaded tileset image: ${tileset.name} (${imagesLoaded}/${totalImages})`);
        if (imagesLoaded === totalImages) {
            console.log('All tileset images loaded, starting game...');
            startGame();
        }
    };
    tilesetImages[tileset.name] = img;


    if (tileset.tiles) {
        tileset.tiles.forEach(tile => {
            const tileGid = tileset.firstgid + tile.id;
            if (tile.properties) {
                tile.properties.forEach(prop => {
                    if (prop.name === "collide" && prop.value === "true") {
                        collideTiles.add(tileGid);
                    }
                    if (prop.name === "disappear" && prop.value === "true") {
                        disappearingTiles.add(tileGid);
                    }
                });
            }
        });
    }
});


const tileSize = TileMaps['map'].tilewidth; // Usually 32
const mapWidth = TileMaps['map'].width;
const mapHeight = TileMaps['map'].height;


let player = {
    x: 32 * 6,
    y: 32 * 4,
    width: 64,
    height: 64,
    speed: 4,
    direction: 'down',
    frame: 0,
    frameCount: 6,
    frameTimer: 0,
    frameInterval: 100,


    collWidth: 35,
    collHeight: 35,
    collOffsetX: (64 - 35) / 2,
    collOffsetY: (64 - 35) / 2,
    facingLeft: false
};


let keys = {};
document.addEventListener('keydown', e => {
    keys[e.code] = true;
});
document.addEventListener('keyup', e => {
    keys[e.code] = false;
});


function findTileset(tileId) {
    for (let i = tilesets.length - 1; i >= 0; i--) {
        if (tileId >= tilesets[i].firstgid) {
            return tilesets[i];
        }
    }
    return null;
}


function drawLayer(layer) {
  const data = layer.data;
  for (let i = 0; i < data.length; i++) {
    if (layer.name === 'layer 1' && hiddenTiles.has(i)) continue;


    const tileGlobalId = data[i];
    if (tileGlobalId === 0) continue;


    const tileset = findTileset(tileGlobalId);
    if (!tileset) continue;


    const tileId = tileGlobalId - tileset.firstgid;
    const img = tilesetImages[tileset.name];
    const columns = Math.floor((tileset.imagewidth - 2 * tileset.margin + tileset.spacing) / (tileset.tilewidth + tileset.spacing));


    const margin = tileset.margin || 0;
    const spacing = tileset.spacing || 0;
    const tileWidth = tileset.tilewidth;
    const tileHeight = tileset.tileheight;


    const sx = margin + (tileId % columns) * (tileWidth + spacing);
    const sy = margin + Math.floor(tileId / columns) * (tileHeight + spacing);


    const dx = (i % mapWidth) * tileSize;
    const dy = Math.floor(i / mapWidth) * tileSize;


    ctx.drawImage(img, sx, sy, tileWidth, tileHeight, dx, dy, tileSize, tileSize);
  }
}



function drawPlayer() {
    let spriteSheet = playerSprites.down;


    if (player.direction === 'up') {
        spriteSheet = playerSprites.up;
    } else if (player.direction === 'down') {
        spriteSheet = playerSprites.down;
    } else if (player.direction === 'side') {
        spriteSheet = playerSprites.side;
    }


    let frameX = player.frame * player.width;
    const frameY = 0;


    ctx.save();


    if (player.direction === 'side' && player.facingLeft) {
        ctx.translate(player.x + player.width / 2, player.y + player.height / 2);
        ctx.scale(-1, 1);
        ctx.translate(-player.width / 2, -player.height / 2);
        ctx.drawImage(
            spriteSheet,
            frameX, frameY,
            player.width, player.height,
            0, 0,
            player.width, player.height
        );
    } else {
        ctx.drawImage(
            spriteSheet,
            frameX, frameY,
            player.width, player.height,
            player.x, player.y,
            player.width, player.height
        );
    }


    ctx.restore();
}


function isCollidingRect(x, y, width, height, layer) {
    const startX = Math.floor(x / tileSize);
    const endX = Math.floor((x + width - 1) / tileSize);
    const startY = Math.floor(y / tileSize);
    const endY = Math.floor((y + height - 1) / tileSize);


    if (startX < 0 || endX >= mapWidth || startY < 0 || endY >= mapHeight) {
        console.log('Collision check out of bounds:', {startX, endX, startY, endY});
        return true;
    }


    for (let ty = startY; ty <= endY; ty++) {
        for (let tx = startX; tx <= endX; tx++) {
            const idx = ty * mapWidth + tx;
            const tileGid = layer.data[idx];
            if (collideTiles.has(tileGid)) {
                console.log(`Collision detected at tile (${tx},${ty}) with GID ${tileGid}`);
                return true;
            }
        }
    }


    return false;
}


function getPlayerTileIndex(layer) {
    const tileX = Math.floor((player.x + player.width / 2) / tileSize);
    const tileY = Math.floor((player.y + player.height / 2) / tileSize);
    if (tileX < 0 || tileX >= mapWidth || tileY < 0 || tileY >= mapHeight) return -1;
    return tileY * mapWidth + tileX;
}


let lastTimestamp = 0;
function updatePlayer(deltaTime) {
    let newX = player.x;
    let newY = player.y;
    let moved = false;


    if (keys['ArrowUp']) { newY -= player.speed; player.direction = 'up'; moved = true; }
    if (keys['ArrowDown']) { newY += player.speed; player.direction = 'down'; moved = true; }
    if (keys['ArrowLeft']) { newX -= player.speed; player.direction = 'side'; player.facingLeft = true; moved = true; }
    if (keys['ArrowRight']) { newX += player.speed; player.direction = 'side'; player.facingLeft = false; moved = true; }


    const collisionLayers = TileMaps['map'].layers.filter(l => ['Ground', 'layer 1'].includes(l.name));


    function isPositionColliding(x, y, width, height) {
        return collisionLayers.some(layer => isCollidingRect(x, y, width, height, layer));
    }


    const collBoxX = newX + player.collOffsetX;
    const collBoxY = newY + player.collOffsetY;
    const collBoxWidth = player.collWidth;
    const collBoxHeight = player.collHeight;


    if (!isPositionColliding(collBoxX, collBoxY, collBoxWidth, collBoxHeight)) {
        player.x = newX;
        player.y = newY;


        if (moved) {
            player.frameTimer += deltaTime;
            if (player.frameTimer > player.frameInterval) {
                player.frame = (player.frame + 1) % player.frameCount;
                player.frameTimer = 0;
            }
        }
    } else {
        player.frame = 0;
    }


    // Disappear tile logic — add to hiddenTiles dynamically
    TileMaps['map'].layers.forEach(layer => {
        if (layer.type === 'tilelayer') {
            const tileIndex = getPlayerTileIndex(layer);
            if (tileIndex !== -1) {
                const gid = layer.data[tileIndex];
                if (disappearingTiles.has(gid) && !hiddenTiles.has(tileIndex)) {
                    hiddenTiles.add(tileIndex);
                    console.log(`Tile at index ${tileIndex} disappeared (GID: ${gid})`);
                }
            }
        }
    });
}


function gameLoop(timestamp = 0) {
    const deltaTime = timestamp - lastTimestamp;
    lastTimestamp = timestamp;


    ctx.clearRect(0, 0, canvas.width, canvas.height);


    // Draw all visible tile layers to include signs and others
    TileMaps['map'].layers.forEach(layer => {
        if (layer.type === 'tilelayer' && layer.visible) {
            drawLayer(layer);
        }
    });


    drawPlayer();
    // Uncomment to visualize collision box during testing
    // drawCollisionBox();


    updatePlayer(deltaTime);


    requestAnimationFrame(gameLoop);
}


function drawCollisionBox() {
    ctx.save();
    ctx.strokeStyle = 'red';
    ctx.lineWidth = 2;
    ctx.strokeRect(
        player.x + player.collOffsetX,
        player.y + player.collOffsetY,
        player.collWidth,
        player.collHeight
    );
    ctx.restore();
}


function startGame() {
    gameLoop();
}